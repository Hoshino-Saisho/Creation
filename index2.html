<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>生产链与等级配平集成计算器</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/handsontable/dist/handsontable.full.min.css">
    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif; padding: 20px 40px; background-color: #f0f2f5; }
        h1, h2 { color: #333; border-bottom: 2px solid #ccc; padding-bottom: 10px; }
        .container { background: #fff; padding: 20px; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); margin-bottom: 30px; }
        .control-panel { margin-bottom: 20px; padding: 15px; background-color: #f7f7f7; border-radius: 5px; display: flex; align-items: center; gap: 20px; }
        .control-panel label { font-weight: bold; }
        .control-panel input { width: 150px; padding: 8px; border: 1px solid #ccc; border-radius: 4px; font-size: 16px; }
        .control-panel button { font-size: 16px; padding: 8px 20px; cursor: pointer; background-color: #007bff; color: white; border: none; border-radius: 5px; }
    </style>
</head>
<body>

    <h1>生产链与等级配平集成计算器</h1>

    <div class="container">
        <h2>一、生产链建筑数量配平（最上游的消耗的最下游的产能请填1）</h2>
        <div class="control-panel">
            <button id="calc-ratio-btn">计算理想配比</button>
        </div>
        <div id="ratio-calculator"></div>
    </div>

    <div class="container">
        <h2>二、现有建筑等级配平</h2>
        <div class="control-panel">
            <label for="total-levels-input">总共可提升等级数:</label>
            <input type="number" id="total-levels-input" value="100" min="0">
        </div>
        <div id="level-calculator"></div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/handsontable/dist/handsontable.full.min.js"></script>
    <script>
        // --- 通用设置 ---
        const BUILDING_SLOTS = 22; // 为您预留22个建筑位置

        // --- 功能一：生产链配平计算器 ---
        const ratioContainer = document.getElementById('ratio-calculator');
        const initialRatioData = Array.from({ length: BUILDING_SLOTS }, () => ["", null, null, null]);
        
        // 示例数据，展示1->3->9的逻辑
        initialRatioData[0] = ['A ', 3, 0, null];
        initialRatioData[1] = ['B ', 30, 1, null];
        initialRatioData[2] = ['C ', 1, 30, null];

        const ratioHot = new Handsontable(ratioContainer, {
            data: initialRatioData,
            colHeaders: ['建筑名称', '自身单次产量', '对上级产品的消耗量', '理想配平数量 (结果)'],
            columns: [{}, { type: 'numeric' }, { type: 'numeric' }, { type: 'numeric', readOnly: true, numericFormat: { pattern: '0,0.000' } }],
            rowHeaders: true, height: 400, stretchH: 'all', licenseKey: 'non-commercial-and-evaluation'
        });

        function calculateRatios() {
            const data = ratioHot.getSourceDataArray().filter(row => row[0]); // 只处理有名称的行
            if (data.length === 0) return;

            // BUG修复：实现累积乘法 (1, 3, 9的逻辑)
            let relativeRatios = new Array(data.length);
            relativeRatios[data.length - 1] = 1;

            for (let i = data.length - 2; i >= 0; i--) {
                const upstreamOutput = parseFloat(data[i][1]) || 0;
                const downstreamConsumption = parseFloat(data[i + 1][2]) || 0;
                if (upstreamOutput === 0) {
                    relativeRatios[i] = Infinity;
                } else {
                    relativeRatios[i] = relativeRatios[i+1] * downstreamConsumption / upstreamOutput;
                }
            }

            let minRatio = Infinity;
            relativeRatios.forEach(r => { if (r > 0 && r < minRatio) minRatio = r; });
            if (minRatio === Infinity) minRatio = 1;

            const multiplier = 1 / minRatio;
            const changes = [];
            relativeRatios.forEach((r, i) => changes.push([i, 3, r * multiplier]));
            
            ratioHot.setDataAtCell(changes);
        }
        document.getElementById('calc-ratio-btn').addEventListener('click', calculateRatios);


        // --- 功能二：建筑等级配平计算器 ---
        const levelContainer = document.getElementById('level-calculator');
        const initialLevelData = Array.from({ length: BUILDING_SLOTS }, () => ["", null, 'n', null, null, null, null]);

        const levelHot = new Handsontable(levelContainer, {
            data: initialLevelData,
            colHeaders: ['建筑名称', '当前等级', '是否锁定', '提升权重', '等级上限', '提升后等级 (结果)', '最终等级 (结果)'],
            columns: [
                {}, // 名称
                { type: 'numeric' }, // 当前等级
                { type: 'checkbox', checkedTemplate: 'y', uncheckedTemplate: 'n' }, // 锁定
                { type: 'numeric' }, // 权重
                { type: 'numeric' }, // 上限
                { type: 'numeric', readOnly: true }, // 提升后
                { type: 'numeric', readOnly: true }  // 最终
            ],
            rowHeaders: true, height: 400, stretchH: 'all', licenseKey: 'non-commercial-and-evaluation'
        });

        function calculateLevels() {
            let totalLevelsToAdd = parseInt(document.getElementById('total-levels-input').value, 10) || 0;
            let data = levelHot.getSourceDataArray().filter(row => row[0]); // 只处理有名称的行
            
            let tempData = data.map(row => ({
                level: parseInt(row[1]) || 0,
                locked: row[2] === 'y' || row[2] === true,
                weight: parseFloat(row[3]) || 0,
                cap: parseInt(row[4]) || Infinity
            }));

            for (let i = 0; i < totalLevelsToAdd; i++) {
                let candidateIndex = -1, minLevel = Infinity, maxWeight = -Infinity;
                tempData.forEach((b, index) => {
                    if (!b.locked && b.level < b.cap) {
                        if (b.level < minLevel) {
                            minLevel = b.level;
                            maxWeight = b.weight;
                            candidateIndex = index;
                        } else if (b.level === minLevel && b.weight > maxWeight) {
                            maxWeight = b.weight;
                            candidateIndex = index;
                        }
                    }
                });

                if (candidateIndex !== -1) {
                    tempData[candidateIndex].level++;
                } else {
                    break;
                }
            }

            const changes = [];
            tempData.forEach((b, index) => {
                changes.push([index, 5, b.level]); // 提升后等级
                changes.push([index, 6, Math.min(b.level, b.cap)]); // 最终等级
            });
            levelHot.setDataAtCell(changes);
        }
        
        // 任何变动都触发等级计算
        levelHot.addHook('afterChange', (changes, source) => {
             if (source !== 'loadData') calculateLevels();
        });
        document.getElementById('total-levels-input').addEventListener('input', calculateLevels);
        
        // 页面加载后运行一次所有计算
        window.addEventListener('DOMContentLoaded', () => {
            calculateRatios();
            calculateLevels();
        });

    </script>
</body>
</html>
